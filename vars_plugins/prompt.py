from __future__ import absolute_import, division, print_function

__metaclass__ = type

DOCUMENTATION = """

This plugin works like the vars_prompt but is more powerfull. The
syntax is a superset of the vars_plugin. The semantics are the same, the
differences are

* It looks for a `questions.yml` file, it just skip if is missing
* At the questions.yml you put what you would put under vars_prompt

Here is an example of question

- name: number
  prompt: Choose a number
  private: no
  required: yes
  default: 10
  choices: [10,20,30,40]
  when: some_value > 10


Conditionals can come from another questions. This is not possible
with vars_prompt plugin so in the next example, the second question
depends on the first's answer being thuthy

- name: foo

- name: bar
  when: foo
"""

import os
import yaml
import re
from datetime import datetime

from ansible import constants as C
from ansible.errors import AnsibleParserError, AnsibleError
from ansible.module_utils._text import to_bytes, to_native, to_text
from ansible.module_utils import six
from ansible.plugins.vars import BaseVarsPlugin
from ansible.inventory.host import Host
from ansible.inventory.group import Group
from ansible.utils.vars import combine_vars
from ansible.utils.display import Display
from ansible.vars.manager import VariableManager
from ansible.template import Templar
from ansible.parsing.dataloader import DataLoader


display = Display()


def create_message(question):
    s = six.StringIO()
    s.write("\n")
    s.write('Type "?" for more info\n')
    prompt = question.get("prompt", question["name"])
    s.write("> {}".format(prompt))
    if "choices" in question:
        for choice in question["choices"]:
            s.write("\n{})".format(choice))
        s.write("\n")
    s.write("?")
    return s.getvalue()


def when(question, result):
    when = question.get("when")
    if when:
        try:
            return eval(when, None, result)
        except Exception as e:
            display.error('Bad when value: "{}"'.format(repr(when)))
            display.error(str(e))
            raise
    return True


def normalize(answer):
    if answer.lower() in ("no", "false"):
        return False
    elif answer.lower() in ("yes", "true"):
        return True
    elif answer == "":
        return None
    else:
        return answer


def write_answers_file(result):
    result = result.copy()  # I dont to change result
    if result.get("answer_file"):
        return
    result["answer_file"] = "yes"
    filename = "answers-{}.yml".format(datetime.now().strftime("%Y%m%d%H"))
    with open(filename, "w") as f:
        f.write("# Automatically generated by prompt plugin\n")
        f.write("# dont edit this file. Variables have dependency\n")
        f.write("# editing would end up with an invalid configuration\n")
        f.write("#\n")
        f.write("# You can use this file to automate next runs with the same config\n")
        f.write("# by using\n")
        f.write("# ansible-playbook deploy.yml -e @{}\n".format(filename))
        f.write("\n")
        yaml.dump(result, f)
    display.display("Written {} file".format(filename))


def private(question):
    p = question.get("private", "yes")
    if isinstance(p, bool):
        return p
    elif p.lower() in ("no", "false"):
        return False
    return True


class Continue(Exception):
    pass


class VarsModule(BaseVarsPlugin):
    result = {}
    finished = False

    def __init__(self, *args, **kwargs):
        super(VarsModule, self).__init__(*args, **kwargs)

    def get_vars(self, *args, **kwargs):
        try:
            return self._get_vars(*args, **kwargs)
        except Exception as e:
            raise AnsibleError(e)

    def _get_vars(self, loader, path, entities):
        result = self.__class__.result
        if self.__class__.finished:
            return result
        super(VarsModule, self).get_vars(loader, path, entities)
        extra_vars = VariableManager(loader=loader).extra_vars
        if extra_vars.get("skip_questions") == "yes":
            return result
        result.update(extra_vars)

        try:
            with open("questions.yml") as f:
                data = yaml.safe_load(f)
        except OSError:  # file not found
            display.display("[INFO] No questions.yml, skipping")
            return result

        for question in data:
            display.debug(result)
            if question["name"] in result:
                continue
            if when(question, result):
                answer = self.do_question(question)
                result.update(answer)

        write_answers_file(result)
        self.__class__.finished = True
        return result

    def get_default_for_message(self, question):
        d = self.get_default(question)
        if private(question) and d is not None:
            return "*" * len(d)
        return d

    def get_default(self, question):
        try:
            return question["default"]
        except KeyError:
            pass
        try:
            return self.template(question["default_template"])
        except KeyError:
            pass
        except Exception as e:
            raise AnsibleError(str(e))

    def template(self, template):
        convert_bare = False if "{{" in template else True
        return Templar(DataLoader(), variables=self.__class__.result).template(
            template, convert_bare=convert_bare, fail_on_undefined=True
        )

    def do_question(self, question):
        message = create_message(question)
        while True:
            answer = display.do_var_prompt(
                question["name"],
                private=private(question),
                prompt=message,
                default=self.get_default_for_message(question),
            )

            if answer.lower() == "?":
                display.display(
                    "\nHELP:\n"
                    + question.get("help", "There is no help for this option, sorry")
                    + "\n"
                )
                continue

            if "validate" in question:
                try:
                    for validation in question["validate"]:
                        locals_ = dict(answer=answer)
                        result = eval(validation["rule"], None, locals_)
                        if result == False:
                            display.display(validation["message"])
                            raise Continue  # continue at outer loop
                except Continue:
                    continue

            required = question.get("required", True)
            if answer == "":
                if not required:
                    return {question["name"]: ""}
                answer = self.get_default(question)
                if answer is None:  # no default
                    display.display("This option can't be blank")
                    continue

            if answer and private(question):
                while True:
                    confirm = display.do_var_prompt(
                        question["name"],
                        True,
                        "Confirm {}".format(question.get("prompt", question["name"])),
                        default=self.get_default_for_message(question),
                    )
                    if confirm == answer:
                        break
                    display.display("Not match!")

            if "choices" in question and answer not in question["choices"]:
                display.display("Invalid answer, sorry :/")
                continue

            if answer != "":
                return {question["name"]: normalize(answer)}
